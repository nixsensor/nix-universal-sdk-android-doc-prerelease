{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nix Universal SDK","text":"<p>A library to allow integration of Nix devices into third-party Android applications.</p> <p>The latest version of this documentation is available online and the latest version of the library is hosted on Maven Central.</p>"},{"location":"#overview","title":"Overview","text":"<p>This library was written to allow integration of Nix devices into third-party Android applications. It provides tools to discover nearby Nix devices, open a connection, perform measurements, and obtain data. Tools are also provided for basic colour conversions and colour difference calculations.</p> <p>For changes introduced in this version, please review the release notes.</p> <p>Note</p> <p>If you are upgrading to version 4.2.x or newer from an earlier version, you will need to update your application to activate your SDK license. See Activating the SDK License for more details.</p> <p>Warning</p> <p>The <code>universalsdk</code> library replaces the previous <code>nixlibrary</code> library. These two libraries should not be used together; remove <code>nixlibrary</code> from your project before adding <code>universalsdk</code>.</p>"},{"location":"#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Android Studio (tested with 2024.2.2)</li> <li>Android Studio project with <code>minSdkVersion</code> 21 or higher</li> <li>Android device with BLE hardware connectivity</li> <li>Active internet connection for device activation (demo / evaluation versions only)</li> <li>Supported Nix devices:<ul> <li>Nix Mini</li> <li>Nix Mini 2</li> <li>Nix Mini 3</li> <li>Nix Pro</li> <li>Nix Pro 2</li> <li>Nix QC</li> <li>Nix Spectro 2</li> <li>Nix Spectro L</li> </ul> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>An activation code is required to use the Nix Universal SDK. Free evaluation codes are available for non-commercial use. To obtain an activation code, visit to the SDK license page.</li> <li>The <code>universalsdk</code> library is available via Maven Central and can be added as a dependency to your Android Studio project. See Adding to Your Android Studio Project for instructions.</li> <li>Once added to your Android Studio project, the <code>LicenseManager</code> can be used to enable the SDK functions included in your license. See Activating the SDK License for more details.</li> <li>Once the license is active, the <code>DeviceScanner</code> can be used to discover nearby and attached devices as <code>IDeviceCompat</code> instances. These objects can be used to open a connection to the the device. See Discovering and Connecting to Nix Devices for more details.</li> <li>Once connected, measurements and other device operations can be performed using the <code>IDeviceCompat</code> instance. Device parameters can also be queried. See Device Operations for more details.</li> <li>Once a measurement has been completed, results are provided as <code>IMeasurementData</code> instances. These objects provide colorimetry data, density, and spectral measurements (if supported by the device). See Handling Measurement Data for more details</li> <li>Several additional utility functions are provided by the <code>ColorUtils</code> class. These include functions for manual colour conversions, delta E calculations, and more. Further details are provided in the API reference (Kotlin and Java)</li> <li>To demonstrate integration of the Nix Universal SDK, an example app is provided with the SDK download.</li> </ol>"},{"location":"#additional-support","title":"Additional Support","text":"<p>This document is not intended as an exhaustive reference. Please refer to the Kotlin and Java API references for further details on the classes and methods provided by the Nix Universal SDK.</p> <p>If you encounter any issues with SDK implementation, please contact us via e-mail at sdk@nixsensor.com.</p>"},{"location":"#privacy-disclaimer","title":"Privacy Disclaimer","text":"<p>Limited anonymous usage data is tracked by the Nix Universal SDK using Google Analytics. No personal user data, color data, or any data which uniquely identifies an individual Nix device is collected. Collected data is subject to the Nix Apps privacy policy. Events and usage data tracked by the Nix SDK are solely limited to the following information:</p> <ul> <li>Device connection events:<ul> <li>Device type (e.g. - Nix Pro, Nix Mini, etc)</li> <li>Device manufacturing batch identifier</li> <li>Nix SDK version</li> </ul> </li> <li>Device color scan events:<ul> <li>Device type</li> <li>Nix SDK version</li> </ul> </li> <li>Reference tile usage events:<ul> <li>Device type</li> <li>Device diagnostics information</li> <li>Nix SDK version</li> </ul> </li> </ul>"},{"location":"activating-license/","title":"Activating the SDK License","text":"<p>An activation code is required to use the Nix Universal SDK. The license determines:</p> <ul> <li>Which device types are available for discovery and connection.</li> <li>Which features and data types are available for connected devices.</li> </ul> <p>By default, all Nix device operations are disabled. It is necessary to activate the license before these are made available to the host application.</p>"},{"location":"activating-license/#obtaining-a-license-key","title":"Obtaining a license key","text":"<p>Free evaluation codes are available for non-commercial use. To obtain an activation code, visit to the SDK license page.</p>"},{"location":"activating-license/#using-the-license-manager","title":"Using the License Manager","text":"<p>License operations are handled via <code>LicenseManager.Shared</code> (see Kotlin or Java APIs).</p>"},{"location":"activating-license/#activating-the-license","title":"Activating the license","text":"<p>A license is activated by calling <code>LicenseManager.Shared.activate()</code> (see Kotlin or Java). This method takes the license options and signature strings as arguments and returns the activation result as a <code>LicenseManagerState</code> value (see Kotlin or Java).</p> <p>Note</p> <p>License activations remain valid within a single session, but do not persist across different application launches. Therefore, it is required to call <code>activate()</code> at least once per session.</p> KotlinJava <pre><code>// Application context, in a Fragment use getContext()\nval context: Context = applicationContext\n\n// Update these string values to match your provided license\nval options = \"REPLACE_WITH_LICENSE_OPTIONS\"\nval signature = \"REPLACE_WITH_LICENSE_SIGNATURE\"\n\n// Result is returned as a `LicenseManagerState` enum\nval activationState = LicenseManager.activate(\n    context = context,\n    options = options,\n    signature = signature)\n</code></pre> <pre><code>// Application context, in a Fragment use getContext()\nContext context = getApplicationContext();\n\n// Update these string values to match your provided license\nString options = \"REPLACE_WITH_LICENSE_OPTIONS\";\nString signature = \"REPLACE_WITH_LICENSE_SIGNATURE\";\n\n// Result is returned as a `LicenseManagerState` enum\nLicenseManagerState activationState = LicenseManager.Shared.activate(\n    context, \n    options, \n    signature);\n</code></pre> <p>Tip</p> <p>The license manager state can also be checked at any time via: <code>LicenseManager.Shared.getState()</code> (see Kotlin or Java).</p> <p>Device operations are only available if the resulting state is equal to <code>LicenseManagerState/ACTIVE</code>. All other values indicate an error state. Refer to the <code>LicenseManagerState</code> Kotlin or Java API documentation for further details.</p> <p>Warning</p> <p>You can switch licenses by calling <code>activate()</code> repeated times within a single session. Doing so will invalidate any open device connections. Any connected Nix devices will need to be disconnected and discovered again using a <code>DeviceScanner</code> after switching licenses.</p>"},{"location":"activating-license/#other-license-properties","title":"Other license properties","text":"<p>Additional license properties can be queried on <code>LicenseManager.Shared</code>. Note that some properties may be blank or empty depending on your license capabilities.</p> KotlinJava <ul> <li>UUID<ul> <li>Unique ID for your SDK license.</li> <li>Refer to <code>LicenseManager.uuid</code></li> </ul> </li> <li>Expiry date<ul> <li>Indicates when the current license ceases to be valid.</li> <li>Refer to <code>LicenseManager.expiry</code></li> </ul> </li> <li>Allocation codes<ul> <li>List of pre-authorized device allocation codes, used when accessing private labelled Nix devices.</li> <li>May be empty for general use cases.</li> <li>Refer to <code>LicenseManager.allocations</code></li> </ul> </li> <li>Allowed device types<ul> <li>List of Nix device types that are supported by the current license.</li> <li>Refer to <code>LicenseManager.allowedDeviceTypes</code> and <code>LicenseManager.isDeviceTypeSupported()</code></li> </ul> </li> <li>Enabled features<ul> <li>List of SDK features enabled by the current license.</li> <li>Refer to <code>LicenseManager.features</code> and <code>LicenseManager.isFeatureEnabled()</code></li> </ul> </li> <li>SDK version<ul> <li>Indicates the current version of the Nix Universal SDK.</li> <li>Refer to <code>LicenseManager.libraryVersion</code></li> </ul> </li> </ul> <ul> <li>UUID<ul> <li>Unique ID for your SDK license.</li> <li>Refer to <code>LicenseManager.Shared.getUuid()</code></li> </ul> </li> <li>Expiry date<ul> <li>Indicates when the current license ceases to be valid.</li> <li>Refer to <code>LicenseManager.Shared.getExpiry()</code></li> </ul> </li> <li>Allocation codes<ul> <li>List of pre-authorized device allocation codes, used when accessing private labelled Nix devices.</li> <li>May be empty for general use cases.</li> <li>Refer to <code>LicenseManager.Shared.getAllocations()</code></li> </ul> </li> <li>Allowed device types<ul> <li>List of Nix device types that are supported by the current license.</li> <li>Refer to <code>LicenseManager.Shared.getAllowedDeviceTypes()</code> and <code>LicenseManager.Shared.isDeviceTypeSupported()</code></li> </ul> </li> <li>Enabled features<ul> <li>List of SDK features enabled by the current license.</li> <li>Refer to <code>LicenseManager.Shared.getFeatures()</code> and <code>LicenseManager.Shared.isFeatureEnabled()</code></li> </ul> </li> <li>SDK version<ul> <li>Indicates the current version of the Nix Universal SDK.</li> <li>Refer to <code>LicenseManager.Shared.getLibraryVersion()</code></li> </ul> </li> </ul>"},{"location":"activating-license/#next-steps","title":"Next steps","text":"<ul> <li>Discovering and Connecting to Nix Devices</li> </ul>"},{"location":"add-to-as/","title":"Adding to Your Android Studio Project","text":"<p>The Nix Universal SDK is provided as a Maven repository. You may install the library from Maven Central, or the provided <code>nixrepo.zip</code> archive can be unzipped and used as a local folder-based repository.</p> <p>Tip</p> <p>The latest stable version of the Nix Universal SDK is hosted on Maven Central. It is recommended to install from this source.</p>"},{"location":"add-to-as/#review-the-end-user-license-agreement","title":"Review the End User License Agreement","text":"<p>Before proceeding, review and accept the End User License Agreement.</p>"},{"location":"add-to-as/#add-dependency-from-maven-central","title":"Add dependency from Maven Central","text":"<ul> <li>Ensure that the <code>mavenCentral()</code> repository is available to your project. This is typically set in the <code>dependencyResolutionManagement</code> section of your project's <code>settings.gradle</code> file; it is usually already included by default.</li> </ul> <pre><code>dependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n\n        // Ensure that Maven Central is included\n        mavenCentral()\n    }\n}\n</code></pre> <ul> <li>Add the <code>com.nixsensor:universalsdk</code> dependency to your app level <code>build.gradle</code> file</li> </ul> <pre><code>dependencies {\n    // Your existing dependencies here\n    // ...\n\n    // Nix Universal SDK\n    implementation 'com.nixsensor:universalsdk:4.2.0'\n}\n</code></pre>"},{"location":"add-to-as/#optional-add-dependencies-for-usb-support","title":"Optional: Add dependencies for USB support","text":"<p>The Nix Universal SDK can communicate with devices directly attached via USB. This feature relies on the <code>usb-serial-for-android</code> library; USB support is automatically enabled once this library is included in your project.</p> <p>Tip</p> <p>If you do not require connections to USB attached devices, you can skip this step.</p> <p>Warning</p> <p>Prior to Nix Universal SDK version 4.2.0, the <code>usb-serial-for-android</code> dependency was included automatically. For SDK version 4.2.0 and later, it is optional and must manually be added to your project if USB support is needed.</p> <ul> <li>Add the <code>jitpack.io</code> repository to your project, typically in the <code>dependencyResolutionManagement</code> section of your project's <code>settings.gradle</code> file.</li> </ul> <pre><code>dependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n\n        // Optional: Jitpack repo needed for usb-serial-for-android\n        maven { url 'https://jitpack.io' }\n    }\n}\n</code></pre> <ul> <li>Add the <code>usb-serial-for-android:v3.8.1</code> dependency to your app level <code>build.gradle</code> file.</li> </ul> <pre><code>dependencies {\n    // Your existing dependencies here\n    // ...\n\n    // Nix Universal SDK\n    implementation 'com.nixsensor:universalsdk:4.2.0'\n\n    // Optional: Enables USB support in Nix Universal SDK\n    implementation 'com.github.mik3y:usb-serial-for-android:v3.8.1'\n}\n</code></pre>"},{"location":"add-to-as/#requesting-required-permissions","title":"Requesting required permissions","text":"<p>As of Android SDK version 23 (Marshmallow), certain permissions must be requested from the user at run-time, including those necessary for discovering nearby Bluetooth devices.</p> <ul> <li>These permissions must be requested at runtime prior to using the <code>DeviceScanner</code> class.</li> <li>The specific permissions to request depend on the Android version. The <code>getRequiredBluetoothPermissions()</code> property getter provides this list of permissions at runtime (see Kotlin or Java APIs).</li> <li>A helper function <code>requestBluetoothPermissions</code> is provided to request the appropriate permissions depending on the currently running Android version (see Kotlin or Java APIs).</li> <li>The helper function <code>isBluetoothPermissionGranted</code> is provided to check if these permissions have already been granted by the user (see Kotlin or Java APIs).</li> </ul> <p>Warning</p> <p>Device discovery will be impossible if the required permissions are not granted by the user.</p> <p>The following example code requests these permissions at the creation of an <code>Activity</code>. Note that requesting this permission does not need to occur immediately at the beginning of your <code>Activity</code>, but simply needs to be performed prior to using the <code>DeviceScanner</code> class.</p> KotlinJava <pre><code>companion object {\n    // Define a constant value of your choice here\n    const val PERMISSION_REQUEST_BLUETOOTH = 1000    \n}\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    // ...\n\n    // Request Bluetooth permissions if necessary\n    if (!IDeviceScanner.isBluetoothPermissionGranted(this)) {\n        IDeviceScanner.requestBluetoothPermissions(\n            activity = this,\n            requestCode = PERMISSION_REQUEST_BLUETOOTH\n        )\n    }\n}\n\noverride fun onRequestPermissionsResult(\n    requestCode: Int,\n    permissions: Array&lt;out String&gt;,\n    grantResults: IntArray\n) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n\n    // Check if all requested permissions have been granted\n    var allGranted = true\n    for (result in grantResults) allGranted =\n        allGranted and (result == PackageManager.PERMISSION_GRANTED)\n\n    when (requestCode) {\n        PERMISSION_REQUEST_BLUETOOTH -&gt; {\n            if (allGranted) {\n                // All permissions granted, OK to use `DeviceScanner`\n                // ...          \n            } else {\n                // Handle permission denial\n                // ...\n            }        \n        }      \n    }\n}\n</code></pre> <pre><code>// Define a constant value of your choice here\nprivate static final int PERMISSION_REQUEST_BLUETOOTH = 1000;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    // ...\n\n    // Request Bluetooth permissions if necessary\n    if (!IDeviceScanner.Companion.isBluetoothPermissionGranted(this)) {\n        IDeviceScanner.Companion.requestBluetoothPermissions(\n            this,\n            PERMISSION_REQUEST_BLUETOOTH);\n    }\n}\n\n@Override\npublic void onRequestPermissionsResult(\n    int requestCode,\n    @NonNull String[] permissions,\n    @NonNull int[] grantResults\n) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n\n    // Check if all requested permissions have been granted\n    boolean allGranted = true;\n    for (int result : grantResults) {\n        allGranted &amp;= (result == PackageManager.PERMISSION_GRANTED);\n    }            \n\n    switch (requestCode) {\n        case PERMISSION_REQUEST_BLUETOOTH: {\n            if (allGranted) {\n                // All permissions granted, OK to use `DeviceScanner`\n                // ... \n            } else {\n                // Handle permission denial\n                // ...\n            }\n        }   break;\n    }\n}\n</code></pre>"},{"location":"add-to-as/#next-steps","title":"Next steps","text":"<ul> <li>Activating the SDK License</li> </ul>"},{"location":"device-operations/","title":"Device Operations","text":""},{"location":"device-operations/#taking-measurements","title":"Taking measurements","text":"<p>Once the device is connected and in an idle state, it is possible to take measurements by calling <code>measure()</code> (see Kotlin or Java APIs). </p> <ul> <li>The varargs <code>modes</code> argument may be omitted to run measurements in all modes supported by the device. This is the recommended option.</li> <li>If the varargs <code>modes</code> arguments are supplied, measurements will be provided only for the specified scan modes. In most cases, this will not speed up the measurement cycle time, so this is not recommended.</li> <li>The measurement operation is asynchronous and will return immediately. While the measurement is in progress, no other commands can be sent to the Nix device.</li> <li>Every call to <code>measure()</code> will result in a callback with either a success or error code.</li> <li>Results of the measurement operation are provided via the <code>onDeviceResult()</code> callback in an <code>OnDeviceResultListener</code> interface (Kotlin or Java). This callback provides two arguments:<ul> <li>A <code>CommandStatus</code> status code (see Kotlin or Java APIs), which will be <code>SUCCESS</code> for a successful operation.</li> <li>A map containing the measurement values as <code>IMeasurementData</code> instances. The keys in this map correspond to the <code>ScanMode</code> enum (see Kotlin or Java APIs) for each measurement value.</li> <li>See Handling Measurement Data for notes on interpreting the measurement data.</li> <li>The supported scan modes for a particular device are provided in the list from <code>getSupportedModes()</code> on the <code>IDeviceCompat</code> instance. Support for a scan mode can also be checked explicitly by calling <code>isModeSupported()</code> on the <code>IDeviceCompat</code> instance. The expected results by device are shown below:</li> </ul> </li> </ul> Device Type M0 M1 M2 Mini \u2610 \u2610 \u2611 Mini 2 \u2610 \u2610 \u2611 Mini 3 \u2610 \u2610 \u2611 Pro \u2610 \u2610 \u2611 Pro 2 \u2610 \u2610 \u2611 QC \u2610 \u2610 \u2611 Spectro 2 (F1.0.0) \u2611 \u2611 \u2610 Spectro 2 (F2.0.0) \u2611 \u2611 \u2611 Spectro L \u2611 \u2611 \u2611 KotlinJava <pre><code>// Device instance\nvar device: IDeviceCompat\n\n// Define callback for measurement\nval measureListener = object : OnDeviceResultListener {\n    override fun onDeviceResult(\n        status: CommandStatus,\n        measurements: Map&lt;ScanMode, IMeasurementData&gt;?\n    ) {\n        when (status) {\n            CommandStatus.SUCCESS -&gt; {\n                // Successful operation\n                // Handle measurement data here\n                // ...        \n            }\n\n            CommandStatus.ERROR_NOT_READY -&gt; {\n                // Did not complete because the device was busy\n                // ...          \n            }\n\n            CommandStatus.ERROR_NOT_SUPPORTED -&gt; {\n                // Did not complete because an unsupported scan mode was\n                // specified\n                // ...          \n            }\n\n            CommandStatus.ERROR_LOW_POWER -&gt; {\n                // Did not complete because the battery level is too low\n                // ...\n            }\n\n            CommandStatus.ERROR_TIMEOUT -&gt; {\n                // Timeout when waiting for result\n                // ...\n            }\n\n            CommandStatus.ERROR_AMBIENT_LIGHT -&gt; {\n                // Did not complete because of ambient light leakage\n                // ...\n            }\n\n            CommandStatus.ERROR_LICENSE -&gt; {\n                // Scan did not complete because of a license issue\n                // Check LicenseManager.state\n                // ...\n            }\n\n            else -&gt; {\n                // Did not complete because of other internal error\n                // ...          \n            }\n        }\n    }\n}\n\n// Run the measurement\ndevice.measure(measureListener)\n</code></pre> <pre><code>// Device instance\nIDeviceCompat device;\n\n// Define callback for measurement\nOnDeviceResultListener measureListener = (commandStatus, measurements) -&gt; {\n    switch (commandStatus) {\n        case SUCCESS:\n            // Successful operation\n            // Handle measurement data here\n            // ...\n            break;\n        case ERROR_NOT_READY:\n            // Did not complete because the device was busy\n            // ...  \n            break;\n        case ERROR_NOT_SUPPORTED:\n            // Did not complete because an unsupported scan mode was\n            // specified\n            // ... \n            break;\n        case ERROR_LOW_POWER:\n            // Did not complete because the battery level is too low\n            // ...\n            break;\n        case ERROR_TIMEOUT:\n            // Timeout when waiting for result\n            // ...\n            break;\n        case ERROR_AMBIENT_LIGHT:\n            // Did not complete because of ambient light leakage\n            // ...\n            break;\n        case ERROR_LICENSE:\n            // Scan did not complete because of a license issue\n            // Check LicenseManager.Shared.state\n            // ...\n            break;\n        default:\n            // Did not complete because of other internal error\n            // ...   \n            break;\n    }\n};\n\n// Run the measurement\ndevice.measure(measureListener);\n</code></pre>"},{"location":"device-operations/#performing-in-field-profiling-calibration-with-reference-tile","title":"Performing in-field profiling / calibration with reference tile","text":"<p>Certain device types support in-field profiling or calibration using a provided reference tile. This process requires first decoding a string from the QR code attached to the reference tile and then directing the user to measure the same tile. Any necessary adjustments/corrections are performed internally by the SDK and/or the Nix device firmware itself.</p> <ul> <li>The in-field calibration procedure may be performed as often or seldom as desired by the user. However, the flag <code>getFieldCalibrationDue()</code> indicates whether or not in-field calibration is recommended for the connected device.<ul> <li>This flag is updated after each regular measurement</li> <li>This flag is determined automatically by both elapsed time and ambient temperature change</li> <li>Calling <code>invalidateFieldCalibration()</code> will force the calibration record to expire on QC and Spectro 2 devices, so that <code>getFieldCalibrationDue()</code> returns <code>true</code></li> </ul> </li> <li>The in-field calibration procedure can exit with status <code>ERROR_SCAN_DELTA</code> if a large difference is detected between the tile reference and measurement. <ul> <li>This status indicates an unexpected tile measurement, possibly due to:<ul> <li>User error (e.g. - a surface other than the reference tile was measured). In this case, the user should repeat the operation</li> <li>The reference tile is damaged</li> <li>The device has drifted too far from factory calibration for the field calibration to be reliable</li> </ul> </li> <li>The failure threshold can vary by device type and can be checked by calling <code>getFieldCalibrationMaxDelta()</code></li> <li>The failure threshold can be overridden by calling <code>setFieldCalibrationMaxDelta()</code> but this is NOT RECOMMENDED</li> </ul> </li> <li>The flag <code>getSupportsFieldCalibration()</code> indicates whether or not a connected device supports this feature. The expected result by device type is shown below: </li> </ul> Device Type Supported Mini \u2610 Mini 2 \u2610 Mini 3 \u2611 Pro \u2610 Pro 2 \u2610 QC \u2611 Spectro 2 \u2611 Spectro L \u2611 <p>The steps to perform in-field profiling include:</p> <ol> <li>Decode the QR code printed on the device reference tile and interpret as a string. Do not parse this data further.</li> <li>Check if the parsed data is valid using <code>isTileStringValid()</code> on the <code>IDeviceCompat</code> instance. If valid, continue to the next step.</li> <li>Instruct the user to place the device on the reference tile.</li> <li>Using the decoded tile string, run the in-field calibration routine by calling <code>runFieldCalibration()</code> on the <code>IDeviceCompat</code> instance and wait for callback (see Kotlin or Java APIs).<ul> <li>This operation is asynchronous and returns immediately. While the operation is in progress, no other commands can be sent to the Nix device (wait for the callback)</li> <li>Every call to <code>runFieldCalibration()</code> will result in a callback with either a success or error code.</li> </ul> </li> </ol> KotlinJava <pre><code>// Device instance\nvar device: IDeviceCompat\n\n// String decoded from the reference tile\nval tileString: String\n\n// Define callback for field calibration\nval calibrateListener = object : OnDeviceResultListener {\n    override fun onDeviceResult(\n        status: CommandStatus,\n        measurements: Map&lt;ScanMode, IMeasurementData&gt;?\n    ) {\n        when (status) {\n            CommandStatus.SUCCESS -&gt; {\n                // Successful operation\n                // ...        \n            }\n\n            CommandStatus.WARNING_TEMPERATURE -&gt; {\n                // Completed successfully, but ambient temperature is outside\n                // of the recommended range\n                // ...\n            }\n\n            CommandStatus.ERROR_SCAN_DELTA -&gt; {\n                // Operation failed because the measured value of the \n                // reference tile is too far from the expected value\n                // (high delta E)\n                // ...           \n            }\n\n            CommandStatus.ERROR_NOT_READY -&gt; {\n                // Did not complete because the device was busy\n                // ...          \n            }\n\n            CommandStatus.ERROR_NOT_SUPPORTED -&gt; {\n                // Did not complete because this device does not support\n                // this command\n                // ...           \n            }\n\n            CommandStatus.ERROR_INVALID_ARGUMENT -&gt; {\n                // Did not complete because the tileString is invalid\n                // ...          \n            }\n\n            CommandStatus.ERROR_LOW_POWER -&gt; {\n                // Did not complete because the battery level is too low\n                // ...\n            }\n\n            CommandStatus.ERROR_TIMEOUT -&gt; {\n                // Timeout when waiting for result\n                // ...\n            }\n\n            CommandStatus.ERROR_AMBIENT_LIGHT -&gt; {\n                // Did not complete because of ambient light leakage\n                // ...\n            }\n\n            CommandStatus.ERROR_LICENSE -&gt; {\n                // Scan did not complete because of a license issue\n                // Check LicenseManager.state\n                // ...\n            }\n\n            else -&gt; {\n                // Did not complete because of other internal error\n                // ...          \n            }\n        }\n    }\n}\n\n// Run field calibration scan\ndevice.runFieldCalibration(calibrateListener, tileString)\n</code></pre> <pre><code>// Device instance\nIDeviceCompat device;\n\n// String decoded from the reference tile\nString tileString;\n\n// Define callback for field calibration\nOnDeviceResultListener calibrateListener = \n    (commandStatus, measurements) -&gt; \n{\n    switch (commandStatus) {\n        case SUCCESS:\n            // Successful operation\n            // ...\n            break;\n        case WARNING_TEMPERATURE:\n            // Completed successfully, but ambient temperature is outside\n            // of the recommended range\n            // ...\n            break;\n        case ERROR_SCAN_DELTA:\n            // Operation failed because the measured value of the reference\n            // tile is too far from the expected value (high delta E)\n            // ...   \n            break;\n        case ERROR_NOT_READY:\n            // Did not complete because the device was busy\n            // ...  \n            break;\n        case ERROR_NOT_SUPPORTED:\n            // Did not complete because this device does not support this\n            // command\n            // ...\n            break;\n        case ERROR_INVALID_ARGUMENT:\n            // Did not complete because the tileString is invalid\n            // ...\n            break;\n        case ERROR_LOW_POWER:\n            // Did not complete because the battery level is too low\n            // ...\n            break;\n        case ERROR_TIMEOUT:\n            // Timeout when waiting for result\n            // ...\n            break;\n        case ERROR_AMBIENT_LIGHT:\n            // Did not complete because of ambient light leakage\n            // ...\n            break;\n        case ERROR_LICENSE:\n            // Scan did not complete because of a license issue\n            // Check LicenseManager.Shared.state\n            // ...\n            break;\n        default:\n            // Did not complete because of other internal error\n            // ...   \n            break;\n    }\n};\n\n// Run field calibration scan\ndevice.runFieldCalibration(calibrateListener, tileString);\n</code></pre>"},{"location":"device-operations/#other-device-options","title":"Other device options","text":"<p>Some Nix devices support certain <code>boolean</code> options. These options are set to be enabled by default (if supported) and do not usually need to be changed. Current state and device support can be checked at runtime on the <code>IDeviceCompat</code> instance:</p> <ul> <li>Applying temperature compensation<ul> <li>Current state: <code>getTemperatureCompensationEnabled()</code></li> <li>Is supported?: <code>getSupportsTemperatureCompensation()</code></li> </ul> </li> <li>Applying in-field calibration<ul> <li>Current state: <code>getFieldCalibrationEnabled()</code></li> <li>Is supported?: <code>getSupportsFieldCalibration()</code></li> </ul> </li> <li>Using on-device haptic feedback<ul> <li>Current state: <code>getHapticFeedbackEnabled()</code></li> <li>Is supported?: <code>getSupportsHapticFeedback()</code></li> </ul> </li> <li>Using on-device RGB feedback<ul> <li>Current state: <code>getRgbFeedbackEnabled()</code></li> <li>Is supported?: <code>getSupportsRgbFeedback()</code></li> </ul> </li> </ul> <p>A summary of device support is shown below, but can be checked at runtime.</p> Device type Temp comp. Field cal. Haptic RGB Mini \u2610 \u2610 \u2610 \u2610 Mini 2 \u2611 \u2610 \u2610 \u2610 Mini 3 \u2611 \u2611 \u2610 \u2611 Pro \u2610 \u2610 \u2610 \u2610 Pro 2 \u2611 \u2610 \u2610 \u2610 QC \u2611 \u2611 \u2610 \u2610 Spectro 2 \u2611 \u2611 \u2611 \u2611 Spectro L \u2611 \u2611 \u2611 \u2611 <p>Changing any of these options may require communication with the device itself and is an asynchronous operation, with the status of the operation provided via a <code>onDeviceResult()</code> callback in the specified <code>OnDeviceResultListener</code> interface.</p> <ul> <li>To enable or bypass temperature compensation, use <code>setTemperatureCompensationEnabled()</code></li> <li>To enable or bypass applying in-field calibration, use <code>setFieldCalibrationEnabled()</code> </li> <li>To enable or disable haptic feedback, use <code>setHapticFeedbackEnabled()</code></li> <li>To enable or disable RGB feedback, use <code>setRgbFeedbackEnabled()</code></li> </ul>"},{"location":"device-operations/#other-device-properties","title":"Other device properties","text":"<p>The <code>IDeviceCompat</code> interface defines other properties that can be read once the device has connected and reached an idle state. These include, but are not limited to:</p> KotlinJava <ul> <li><code>extPowerState</code>: status of external power connection / charging</li> <li><code>batteryLevel</code>: current battery level, <code>null</code> otherwise</li> <li><code>firmwareVersion</code>: device firmware revision</li> <li><code>hardwareVersion</code>: device hardware revision</li> <li><code>softwareVersion</code>: device software revision</li> <li><code>serialNumber</code>: device serial number</li> <li><code>note</code>: device allocation / production code</li> <li><code>providesSpectral</code>: indicates whether or not this device provides spectral data</li> <li><code>providesDensity</code>: indicates whether or not this device provides density data</li> <li><code>supportedModes</code>: list of supported measurement modes for this device</li> <li><code>supportedReferences</code>: list of supported reference white values provided by the measurement data from this device</li> </ul> <ul> <li><code>getExtPowerState()</code>: status of external power connection / charging</li> <li><code>getBatteryLevel()</code>: current battery level, <code>null</code> otherwise</li> <li><code>getFirmwareVersion()</code>: device firmware revision</li> <li><code>getHardwareVersion()</code>: device hardware revision</li> <li><code>getSoftwareVersion()</code>: device software revision</li> <li><code>getSerialNumber()</code>: device serial number</li> <li><code>getNote()</code>: device allocation / production code</li> <li><code>getProvidesSpectral()</code>: indicates whether or not this device provides spectral data</li> <li><code>getProvidesDensity()</code>: indicates whether or not this device provides density data</li> <li><code>getSupportedModes()</code>: list of supported measurement modes for this device</li> <li><code>getSupportedReferences()</code>: list of supported reference white values provided by the measurement data from this device</li> </ul> <p>Warning</p> <p>The <code>providesDensity</code> and <code>providesSpectral</code> properties indicate whether or not the hardware device is capable of providing these data types. However, these measurements will only be available if these features are enabled by the current license. See Other license properties for more details.</p>"},{"location":"device-operations/#next-steps","title":"Next steps","text":"<ul> <li>Handling Measurement Data</li> </ul>"},{"location":"discovering-connecting/","title":"Discovering and Connecting to Nix Devices","text":"<p>Regardless of device type, each unique Nix device can be represented by an object that conforms to the <code>IDeviceCompat</code> interface (see Kotlin or Java APIs). To obtain instances of the device object, they need to first be discovered using the <code>DeviceScanner</code> (see Kotlin or Java APIs). They can also be recalled at a later time directly using their <code>id</code> property (for Bluetooth connected devices only).</p>"},{"location":"discovering-connecting/#device-discovery","title":"Device discovery","text":"<p>The <code>DeviceScanner</code> implements the <code>IDeviceScanner</code> interface (see Kotlin or Java APIs) and searches for nearby Nix devices using Bluetooth. The <code>DeviceScanner</code> will also report devices connected via USB. Scanner events are reported via:</p> <ul> <li><code>OnScannerStateChangeListener</code>:<ul> <li>Optional callback interface which reports when the scanner starts and stops searching for devices.</li> <li>API reference: Kotlin or Java.</li> <li>This is set using <code>setOnScannerStateChangeListener()</code>.</li> </ul> </li> <li><code>OnDeviceFoundListener</code>:<ul> <li>Callback interface which is called by the scanner each time that an <code>IDeviceCompat</code> instance has been found.</li> <li>API reference: Kotlin or Java.</li> <li>Note that this will be called both when a new device is found and when the RSSI/signal strength of a previously discovered device has changed. It is possible to use the <code>id</code> parameter as a means to uniquely identify discovered devices.</li> </ul> </li> </ul> <p>Note</p> <p>Devices can only be discovered or recalled while your SDK licence is in an <code>LicenseManagerState/ACTIVE</code> state; see <code>LicenseManager.Shared.getState()</code> for Kotlin or Java. Only device types supported by your license can be discovered and connected; see <code>LicenseManager.Shared.getAllowedDeviceTypes()</code> for Kotlin or Java.</p> <p>To use the <code>DeviceScanner</code>:</p> <ul> <li>Initialize a scanner instance</li> <li>Optionally set a <code>OnScannerStateChangeListener</code>, if it is desired to track when the scanner starts and stops a device search.</li> <li>Check the scanner state, which will be <code>DeviceScannerState/IDLE</code> if properly initialized.<ul> <li>The scanner state is available via <code>IDeviceScanner.getState()</code> (see Kotlin or Java APIs).</li> <li>See a list possible states for Kotlin or Java.</li> <li>If the state is <code>DeviceScannerState/ERROR_LICENSE</code>, check <code>LicenseManager.Shared.getState()</code> for further details. </li> </ul> </li> <li>Start the scanner using <code>start()</code> (see Kotlin or Java APIs).<ul> <li>By default, the scanner will search for a period <code>DEFAULT_GENERAL_SCAN_PERIOD_MS</code>, but this interval can be overridden by providing an argument for <code>scanPeriodMs</code>.</li> </ul> </li> <li>Observe discovered devices via the <code>onScanResult()</code> in the <code>OnDeviceFoundListener</code> interface. At this stage, it is valid to check a limited number of parameters on the device object:<ul> <li><code>getId()</code>: Device identifier string (see Kotlin or Java APIs).</li> <li><code>getRssi()</code>: Device signal strength (-127 to 0). Will be 0 for USB connected devices (see Kotlin or Java APIs).</li> <li><code>getInterfaceType()</code>: Indicates whether the device was found via Bluetooth or USB connection (see Kotlin or Java APIs).</li> <li><code>getType()</code>: Indicates the specific device type (see Kotlin or Java APIs).</li> <li><code>getName()</code>: Full name of the device (e.g. 'Nix Spectro 2', see Kotlin or Java APIs).</li> </ul> </li> <li>The device search will run for the specified duration, after which <code>onScannerStopped()</code> is called. The device search can also be manually stopped using <code>stop()</code>.</li> </ul> KotlinJava <pre><code>// Define the OnScannerStateChangeListener\nval scannerStateListener = object : OnScannerStateChangeListener {\n    override fun onScannerStarted(sender: IDeviceScanner) {\n        // Scanner has started ...\n    }\n\n    override fun onScannerStopped(sender: IDeviceScanner) {\n        // Scanner has stopped ...\n    }\n}\n\n// Define the OnDeviceFoundListener\nval deviceFoundListener = object : OnDeviceFoundListener {\n    override fun onScanResult(sender: IDeviceScanner, device: IDeviceCompat) {\n        // Nearby device found\n        // Handle discovery here ...\n\n        // Valid to query some parameters now:\n        Log.d(TAG, String.format(\n            \"Found %s (%s) at RSSI %d\", \n            device.id, \n            device.name, \n            device.rssi)\n        )\n    }\n}\n\n// Application context, in a Fragment use getContext()\nval context: Context = applicationContext\n\n// Initialize the scanner\nval scanner = DeviceScanner(context)\nscanner.setOnScannerStateChangeListener(scannerStateListener)\n\n// Start the scanner\nif (scanner.state == IDeviceScanner.DeviceScannerState.IDLE) {\n    scanner.start(listener = deviceFoundListener)\n} else {\n    // Check the error state and handle accordingly ...\n}    \n</code></pre> <pre><code>// Define the OnScannerStateChangeListener\nIDeviceScanner.OnScannerStateChangeListener stateChangeListener = \n    new IDeviceScanner.OnScannerStateChangeListener() \n{\n    @Override\n    public void onScannerStarted(@NonNull IDeviceScanner sender) {\n        // Scanner has started\n        // ...\n    }\n\n    @Override\n    public void onScannerStopped(@NonNull IDeviceScanner sender) {\n        // Scanner has stopped\n        // ...\n    }\n};\n\n// Define the OnDeviceFoundListener\nIDeviceScanner.OnDeviceFoundListener deviceFoundListener = \n    new IDeviceScanner.OnDeviceFoundListener() \n{\n    @Override\n    public void onScanResult(\n        @NonNull IDeviceScanner sender,\n        @NonNull IDeviceCompat device\n    ) {\n        // Nearby device found\n        // Handle discovery here ...\n\n        // Valid to query some parameters now:\n        Log.d(TAG, String.format(\n            \"Found %s (%s) with RSSI %d\", \n            device.getId(), \n            device.getName(), \n            device.getRssi()));\n    }\n};\n\n// Application context, in a Fragment use getContext()\nContext context = getApplicationContext();\n\n// Initialize the scanner\nIDeviceScanner scanner = new DeviceScanner(context);\nscanner.setOnScannerStateChangeListener(scannerStateListener);    \n\n// Start the scanner\nif (scanner.getState() == IDeviceScanner.DeviceScannerState.IDLE) {\n    scanner.start(\n        deviceFoundListener,\n        IDeviceScanner.DEFAULT_GENERAL_SCAN_PERIOD_MS);\n} else {\n    // Check the error state and handle accordingly ...\n}    \n</code></pre>"},{"location":"discovering-connecting/#recalling-a-known-nix-device","title":"Recalling a known Nix device","text":"<p>For Bluetooth connected devices only, it is possible to construct an <code>IDeviceCompat</code> instance directly if the hardware address and device type is known. The constructor takes the hardware address and device names as arguments.</p> <ul> <li>The device address must match the original value queried from <code>getId()</code>. Note that this corresponds to the hardware address of the advertising Bluetooth device</li> <li>The device name must match the original value queried from <code>getName()</code>. Note that this corresponds to the device name as advertised on Bluetooth. If the <code>DeviceType</code> enum is known, this also corresponds to <code>getFullName()</code> (see Kotlin or Java APIs for <code>DeviceType</code>).</li> </ul> KotlinJava <pre><code>// Application context, in a Fragment use getContext()\nval context: Context = applicationContext\n\n// Hardware address of known device\nval exampleAddress: String = \"00:AA:11:BB:22:CC\"\n\n// Name of known device / type (must match advertised name)\nval exampleName: String = \"Nix Spectro 2\"\n\n// Create IDeviceCompat instance\nval recalledDevice: IDeviceCompat = DeviceCompat(\n    context = context,\n    address = exampleAddress,\n    name = exampleName\n)\n</code></pre> <pre><code>// Application context, in a Fragment use getContext()\nContext context = getApplicationContext();\n\n// Hardware address of known device\nString exampleAddress = \"00:AA:11:BB:22:CC\";\n\n// Name of known device / type (must match advertised name)\nString exampleName = \"Nix Spectro 2\";\n\n// Create IDeviceCompat instance\nIDeviceCompat recalledDevice = new DeviceCompat(\n    context, \n    exampleAddress, \n    exampleName, \n    Integer.MIN_VALUE);\n</code></pre>"},{"location":"discovering-connecting/#opening-a-connection","title":"Opening a connection","text":"<p>Once an <code>IDeviceCompat</code> instance has been obtained, a connection can be opened by calling <code>connect()</code> (see Kotlin or Java APIs). Connection state changes are provided via an <code>OnDeviceStateChangeListener</code> interface. The connection can be cancelled or closed normally by later calling <code>disconnect()</code>.</p> <p>The steps necessary for connecting include:</p> <ol> <li>Implement the <code>OnDeviceStateChangeListener</code> interface in your class</li> <li>Stop the <code>DeviceScanner</code> before opening a connection, if still running.<ul> <li>It is safe to call <code>stop()</code> on the <code>DeviceScanner</code> at any time, even if already stopped.</li> </ul> </li> <li>Start the connection process by calling <code>connect()</code>.<ul> <li>The connection process is asynchronous and <code>connect()</code> will return immediately. If a connection activity indicator is shown, it can be shown immediately before calling this method.</li> <li>A call to <code>connect()</code> will always result in either the <code>onConnected()</code> or <code>onDisconnected()</code> callback being triggered.</li> <li>Device operations are not possible until the <code>onConnected()</code> callback is received (successful connection)</li> <li>If the connection process fails, the <code>onDisconnected()</code> callback will be invoked with an appropriate status code indicating the cause of the error.</li> <li><code>onDisconnected()</code> will also be called later whenever the device is disconnected. This can occur normally (i.e. - if the host application calls <code>disconnect()</code> on the <code>IDeviceCompat</code> instance), or abnormally (i.e. - if the connection is dropped due to an error or low Bluetooth signal strength).</li> <li>Your license is linked to a specific allocation of Nix devices and will not operate with devices from another allocation.<ul> <li>At connection time, the SDK will read an allocation code stored on the Nix device and compare to the license information.</li> <li>If this check does not pass, the SDK will contact a Nix authentication server to check if that device serial number is authorized.</li> <li>If the device cannot be authenticated (i.e. \u2013 an unknown allocation code was found and an internet connection is unavailable), the device will be disconnected with the status <code>ERROR_UNAUTHORIZED</code>.</li> <li>The internet connection is required only once every 30 days \u2013 once authorized, this status is saved, and connections can be made offline for this time period.</li> </ul> </li> </ul> </li> <li>When the user has finished using the device, the connection can be closed by calling <code>disconnect()</code>.</li> </ol> KotlinJava <pre><code>// Define the OnDeviceStateChangeListener\nval deviceStateListener = object : OnDeviceStateChangeListener {\n    override fun onConnected(\n        sender: IDeviceCompat\n    ) {\n        // Device has connected successfully\n        // Device properties can now be queried\n        // Device commands/operations can now run\n        // ...\n    }\n\n    override fun onDisconnected(\n        sender: IDeviceCompat,\n        status: DeviceStatus\n    ) {\n        // Handle status codes here, if desired in your application\n        // At minimum, should check for ERROR_UNAUTHORIZED and \n        // ERROR_LICENSE cases\n        when (status) {\n            // Device not authorized for this license UUID\n            DeviceStatus.ERROR_UNAUTHORIZED -&gt; {\n                // ...\n            }\n\n            // There is an issue with the LicenseManager\n            // Check LicenseManager.state\n            DeviceStatus.ERROR_LICENSE -&gt; {\n                // ...\n            }\n\n            // Normal disconnect, triggered by device.disconnect()\n            DeviceStatus.SUCCESS -&gt; {\n                // ...\n            }\n\n            // Nix device dropped the connection\n            DeviceStatus.ERROR_DROPPED_CONNECTION -&gt; {\n                // ...\n            }\n\n            // Connection to Nix device timed out\n            DeviceStatus.ERROR_TIMEOUT -&gt; { \n                // ...\n            }\n\n            // Other internal errors\n            DeviceStatus.ERROR_MAX_ATTEMPTS,\n            DeviceStatus.ERROR_UNSUPPORTED_DEVICE,\n            DeviceStatus.ERROR_INTERNAL -&gt; { \n                // ...\n            }\n        }\n    }\n\n    override fun onBatteryStateChanged(\n        sender: IDeviceCompat,\n        newState: Int\n    ) {\n        super.onBatteryStateChanged(sender, newState)\n        // Battery level has updated\n        // ...\n    }\n\n    override fun onExtPowerStateChanged(\n        sender: IDeviceCompat,\n        newState: Boolean\n    ) {\n        super.onExtPowerStateChanged(sender, newState)\n        // External power has been connected or disconnected\n        // ...\n    }        \n}\n\n// Device instance that has already been found by the DeviceScanner\nvar device: IDeviceCompat\n\n// Initiate the connection\ndevice.connect(deviceStateListener)\n</code></pre> <pre><code>// Define the OnDeviceStateChangeListener\nIDeviceCompat.OnDeviceStateChangeListener deviceStateListener = \n    new IDeviceCompat.OnDeviceStateChangeListener() \n{\n    @Override\n    public void onConnected(@NonNull IDeviceCompat sender) {\n        // Device has connected successfully\n        // Device properties can now be queried\n        // Device commands/operations can now run\n        // ...\n    }\n\n    @Override\n    public void onDisconnected(\n        @NonNull IDeviceCompat sender, \n        @NonNull DeviceStatus status) \n    {\n        // Handle status codes here, if desired in your application\n        // At minimum, should check for ERROR_UNAUTHORIZED and \n        // ERROR_LICENSE cases\n        switch (status) {\n            case ERROR_UNAUTHORIZED:\n                // Device not authorized for this license UUID\n                // ...\n                break;\n            case ERROR_LICENSE:\n                // There is an issue with the LicenseManager\n                // Check LicenseManager.Shared.getState()\n                break;\n            case SUCCESS:\n                // Normal disconnect, triggered by device.disconnect()\n                //...\n                break;\n            case ERROR_DROPPED_CONNECTION:\n                // Nix device dropped the connection\n                // ...\n                break;\n            case ERROR_TIMEOUT:\n                // Connection to Nix device timed out\n                // ...\n                break;\n            case ERROR_MAX_ATTEMPTS:\n            case ERROR_UNSUPPORTED_DEVICE:\n            case ERROR_INTERNAL:\n                // Other internal errors\n                // ...\n                break;\n        }\n    }\n\n    @Override\n    public void onBatteryStateChanged(\n        @NonNull IDeviceCompat sender, \n        int newState\n    ) {\n        // Battery level has updated\n        // ...\n    }\n\n    @Override\n    public void onExtPowerStateChanged(\n        @NonNull IDeviceCompat sender, \n        boolean newState\n    ) {\n        // External power has been connected or disconnected\n        // ...\n    }\n};\n\n// Device instance that has already been found by the DeviceScanner\nIDeviceCompat device;\n\n// Initiate the connection\ndevice.connect(deviceStateListener);\n</code></pre>"},{"location":"discovering-connecting/#next-steps","title":"Next steps","text":"<ul> <li>Device Operations </li> </ul>"},{"location":"example-apps/","title":"Example Application","text":""},{"location":"example-apps/#android-application-written-in-kotlin","title":"Android application written in Kotlin","text":"<p>An example app and its complete source code are provided with the <code>NixUniversalSDK</code> download, available online. To review the example, use Android Studio to open the <code>example-android</code> folder.</p> <p>The example app demonstrates:</p> <ul> <li>Activating and displaying license information</li> <li>Device discovery on Bluetooth and USB interfaces</li> <li>Opening and closing a connection to a device</li> <li>Displaying additional device info (serial number, battery level, etc.)</li> <li>Toggling device options (haptic feedback, RGB feedback, etc.)</li> <li>Taking measurements</li> <li>Obtaining colorimetry and spectral data from measurements</li> <li>Performing in-field calibration on the provided reference tile</li> <li>Displaying additional measurement information (temperature, scan settings, etc.)</li> </ul> <p>Tip</p> <p>The example application will activate the SDK license at launch using the values entered in <code>LicenseKey.kt</code>. The example also allows entry of different license codes at runtime.</p> <p> </p> Demo app screenshot"},{"location":"example-apps/#next-steps","title":"Next steps","text":"<ul> <li>Get additional support</li> </ul>"},{"location":"handling-measurements/","title":"Handling Measurement Data","text":"<p>Measurements from Nix devices are provided as objects conforming to the <code>IMeasurementData</code> interface. These contain all data and metadata to completely describe the measurement. Color, spectral, and density data are obtained from the <code>IMeasurementData</code> instance as <code>IColorData</code>, <code>ISpectralData</code>, and <code>IDensityData</code> respectively. The differences between these object types are listed below.</p>"},{"location":"handling-measurements/#imeasurementdata","title":"IMeasurementData","text":"<ul> <li>Corresponds to a single measurement in a single <code>ScanMode</code> from a Nix device</li> <li>Provides color data as <code>IColorData</code><ul> <li>To get color data, call <code>toColorData()</code></li> <li>All devices provide data for D50/2\u00b0 reference white</li> <li>Some devices provide additional color data for other reference white values</li> <li>To check if available, call <code>providesColor()</code></li> </ul> </li> <li>May provide spectral data as <code>ISpectralData</code>, depending on the device type and license capabilities<ul> <li>To check if available, use <code>getProvidesSpectral()</code> </li> <li>To get spectral data, use <code>getSpectralData()</code> </li> </ul> </li> <li>May provide density data as <code>IDensityData</code>, depending on the device type and license capabilities<ul> <li>To check if available, use <code>getProvidesDensity()</code> </li> <li>To get density data, use <code>toDensityData()</code> </li> </ul> </li> <li>The measurement data contains all data and metadata to completely describe the measurement<ul> <li>For maximum fidelity and ease of use when saving data, save the string data from <code>getRaw()</code>.</li> <li>The raw string value can be used to reconstruct measurement data using <code>fromRaw()</code>.</li> </ul> </li> <li>Refer to the <code>IMeasurementData</code> API documentation for full details (Kotlin or Java)</li> </ul>"},{"location":"handling-measurements/#supported-icolordata-output-based-on-device-type","title":"Supported <code>IColorData</code> output based on device type","text":"Reference Mini Mini 2 Mini 3 Pro Pro 2 QC Spectro 2 Spectro L A/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 A/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 C/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 C/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D50/2\u00b0 \u2611 \u2611 \u2611 \u2611 \u2611 \u2611 \u2611 \u2611 D50/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D55/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D55/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D65/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D65/10\u00b0 \u2610 \u2611 \u2611 \u2610 \u2611 \u2611 \u2611 \u2611 D75/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D75/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F2/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F2/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F7/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F7/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F11/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F11/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611"},{"location":"handling-measurements/#supported-ispectraldata-and-idensitydata-output-based-on-device-type","title":"Supported <code>ISpectralData</code> and <code>IDensityData</code> output based on device type","text":"Device Type Supports spectral output Supports density output Mini \u2610 \u2610 Mini 2 \u2610 \u2610 Mini 3 \u2610 \u2610 Pro \u2610 \u2610 Pro 2 \u2610 \u2610 QC \u2610 \u2610 Spectro 2 \u2611 \u2611 Spectro L \u2611 \u2611 <p>Warning</p> <p>The table above indicates whether or not the hardware device is capable of providing these data types. However, these values will only be available if enabled by the active license. See Other license properties for more details.</p> <p>Tip</p> <p>The <code>IMeasurementData</code> flags <code>providesSpectral</code> and <code>providesDensity</code> take into account both the device and license capabilities and can be used to determine if these data are currently available.</p>"},{"location":"handling-measurements/#icolordata","title":"IColorData","text":"<ul> <li>Consists of colorimetry data for a single reference white point (e.g. - D50/2\u00b0) and single measurement mode (e.g. - M2)</li> <li>Can be obtained directly from an <code>IMeasurementData</code> object, from or an <code>ISpectralData</code> object</li> <li>Full description of a color consisting of:<ul> <li>Type / color system: <code>getType()</code> as <code>ColorType</code> enum </li> <li>Value: <code>getValue()</code> as double array (3 channels)<ul> <li>Format matches the system defined by <code>getType()</code></li> </ul> </li> <li>Reference white point: <code>getReference()</code> as <code>ReferenceWhite</code> enum</li> <li>Scan mode: <code>getMode()</code> as <code>ScanMode</code> enum</li> </ul> </li> <li>Regardless of <code>getType()</code>, the color is always backed internally by a CIEXYZ value</li> <li>Color can be converted between any of the types specified in the <code>ColorType</code> enum by calling <code>convertTo()</code></li> <li>Delta E to another <code>IColorData</code> instance can be evaluated using <code>compareTo()</code>.<ul> <li>Both <code>IColorData</code> objects must share the same reference, otherwise the result with be NaN</li> <li>If the color difference type is not specified, the default is CIE2000. See the <code>ColorDifferenceType</code> enum for other options (Kotlin or Java)</li> </ul> </li> <li>sRGB value can be fetched using <code>getRgbValue()</code></li> <li>Refer to the <code>IColorData</code> API documentation for full details (Kotlin or Java)</li> </ul>"},{"location":"handling-measurements/#ispectraldata","title":"ISpectralData","text":"<ul> <li>Consists of spectral data for a single measurement mode</li> <li>Obtained from an <code>IMeasurementData</code> object that supports spectral data</li> <li>Full description of the spectral measurement consisting of:<ul> <li>Scan mode: <code>getMode()</code> as <code>ScanMode</code> enum</li> <li>Wavelength values: <code>getLambda()</code> as integer array</li> <li>Spectral values: <code>getValue()</code> as float array</li> </ul> </li> <li>Can be used to obtain density data as <code>IDensityData</code> using <code>toDensityData()</code>, if enabled by the current license</li> <li>Can be used to obtain colorimetry data as <code>IColorData</code> object for any reference white using <code>toColorData()</code></li> <li>sRGB value can be fetched for any reference white using <code>toRgbValue()</code></li> <li>Refer to the <code>ISpectralData</code> API documentation for full details (Kotlin or Java)</li> </ul>"},{"location":"handling-measurements/#idensitydata","title":"IDensityData","text":"<ul> <li>Consists of density data for a single measurement mode and single 'ISO status' / lookup table</li> <li>Obtained from an <code>IMeasurementData</code> object that supports spectral data, or an <code>ISpectralData</code> object</li> <li>Description of the density values for a specific 'ISO Status' consisting of:<ul> <li>Scan mode: <code>getMode()</code> as <code>ScanMode</code></li> <li>ISO status: <code>getStatus()</code> as <code>DensityStatus</code> enum</li> <li>Density values: <code>getValue()</code> as double array (4 channels)<ul> <li>Index 0: C</li> <li>Index 1: M</li> <li>Index 2: Y</li> <li>Index 3: K</li> </ul> </li> <li>Automatic density index: <code>getAutoIndex()</code> as integer value</li> </ul> </li> <li>Refer to the <code>IDensityData</code> API documentation for full details (Kotlin or Java)</li> </ul> <p>Tip</p> <p>The <code>ColorUtils</code> class provides many helpful functions for manual colour conversions and delta E calculations. Further details are provided in the API reference (Kotlin and Java).</p>"},{"location":"handling-measurements/#next-steps","title":"Next steps","text":"<ul> <li>Review the example app</li> <li>Get additional support</li> </ul>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#version-420","title":"Version 4.2.0","text":"<ul> <li>Released on February 21, 2025</li> <li>Nix Universal SDK functions must now be enabled with a license key using <code>LicenseManager</code> (see Kotlin or Java). For further details, refer to Activating the SDK License.</li> <li>Existing <code>enum</code> types have added cases related to <code>LicenseManager</code> errors. Refer to the API documentation linked below for additional details.<ul> <li><code>CommandStatus/ERROR_LICENSE</code> (see Kotlin or Java)</li> <li><code>DeviceScannerState/ERROR_LICENSE</code> (see Kotlin or Java)</li> <li><code>DeviceStatus/ERROR_LICENSE</code> (see Kotlin or Java)</li> </ul> </li> <li><code>ISpectralData.toDensityData()</code> now returns an optional data type (see Kotlin or Java).<ul> <li>The result is <code>null</code> when <code>LicenseFeature/DENSITY_DATA</code> is not provided by the active license.</li> </ul> </li> <li>The dependency on <code>usb-serial-for-android</code> has been changed from 'required' to 'optional'<ul> <li>This dependency is used provide support for devices directly attached via USB. It can be safely omitted if USB support is not required.</li> <li>To enable USB device support, include this dependency in your application's <code>build.gradle</code> file. Refer to Add dependencies for USB support for further details.</li> </ul> </li> </ul>"},{"location":"release-notes/#version-410","title":"Version 4.1.0","text":"<ul> <li>Released on July 31, 2023</li> <li>Added support for Nix Spectro L devices</li> <li>Added <code>IDeviceCompat/fieldCalibrationMaxDelta</code><ul> <li>Allows override of the maximum Delta E threshold used when performing in-field calibration</li> <li>Review the API reference (Kotlin or Java getter and setter) for additional details</li> </ul> </li> <li>Updated field calibration routine for Nix Spectro 2 devices<ul> <li>API calls to <code>IDeviceCompat/runFieldCalibration</code> function are unchanged</li> <li>Additional diagnostics are performed during the white tile scan on Spectro 2 type devices. As a result, the calibration command can now take 5 - 10 seconds to complete</li> <li>The operation can now fail with status <code>CommandStatus/ERROR_SCAN_DELTA</code> if the tile measurement delta exceeds the allowable threshold</li> </ul> </li> <li>Added <code>IDeviceCompat/invalidateFieldCalibration</code> function<ul> <li>This function forces the field calibration record to expire on QC and Spectro 2 type devices. </li> <li>Review the API reference (Kotlin or Java) for additional details</li> </ul> </li> </ul>"},{"location":"release-notes/#version-402","title":"Version 4.0.2","text":"<ul> <li>Released on February 13, 2023</li> <li>Added ISO Density calculations and supporting classes<ul> <li>Density data can be obtained from measurements as <code>IDensityData</code></li> <li>The Handling Measurement Data article has been updated to reflect its usage</li> </ul> </li> </ul>"},{"location":"release-notes/#version-400","title":"Version 4.0.0","text":"<ul> <li>Released on January 6, 2023</li> <li>Initial release for <code>NixUniversalSDK</code>, replacing the older <code>nixlibrary</code> project</li> </ul>"}]}